import React from "react";
import { useMemo } from "react";

let countOfIsFiveRenders = 0;

export default React.memo(
    function IsFive({ value }) {
        console.warn(
            `IsFive component was rendered ${++countOfIsFiveRenders} times`
        );

        // обращаю внимание что result не становится функцией, а лишь
        // получает результат выполнения функции, переданной в
        // React.useMemo
        // в константу result пападёт возвращаемая строка

        // а теперь как это работает
        // функция в useMemo отрабатывает схожим образом с useCallback
        // и немного схоже с useEffect
        // useMemo вовзращает значение, возвращаемое в передаваемой
        // коллбэк функции. Повторно коллбэк функция запустится,
        // и вернёт значение, только в случае изменения зависимостей,
        // которые передаются в массиве вторым аргументом
        // различия с useCallback в том, что useMemo возвращет
        // значение, при изменении зависимостей, а useCallback
        // возвращает функцию, (ту самую, которая передаётся
        // как коллбэк), и переопределяет её, только при
        // изменении зависимостей. По сути useCallback просто
        // создаёт функцию, которая не будет переопределятся,
        // без изменений зависимостей, когда useMemo делает
        // тоже самое для переменной
        // ПРИМЕЧЕНИЕ: по сути этот компонент и так не будет
        // рендерится если не будет выполнено условие React.memo
        // ниже, поэтому useMemo здесь с точки зрения
        // функционала может быть не нужен
        const result = useMemo(() => {
            // let i = 0;
            // while (i <= 600000000) i++;
            for (let i = 0; i < 600000000; i++) {}

            return value === 5 ? "Это пять!" : "Не пять...";
            // переопределение result будет происходить
            // если меняется props value
            // (при этом это будет происходить только тогда,
            // когда будет запускаться рендер, то есть по
            // условию React.memo)
        }, [value]);

        return <div>{result}</div>;
    },
    // ре-рендер компонента будет происходить только
    // если новое или старое значение пропса value === 5
    (prevProps, newProps) => {
        return !(newProps.value === 5 || prevProps.value === 5);
    }
);
